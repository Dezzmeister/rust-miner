# TsengToken Miner

Mining software for TsengToken. Separate from wallet software which will be written in Go.

## Development

To develop the CPU code, clone this repo and build with

`cargo build`

or

`cargo build --release`.

To develop the GPU code, clone [rust-miner-kernel](https://github.com/Dezzmeister/rust-miner-kernel.git) next to this repo. To build the GPU code as well, run

`cargo build [--release] --features kernels`

Note that this will build the GPU + CPU code. You can still do `cargo build [--release]` to build just the CPU code.

## Running

`cargo run <difficulty>` to build and run in debug mode. Note that the debug build is orders of magnitude slower than the release build; to run at full speed do

`cargo build --release --features kernels`

The `<difficulty>` is a number that specifies the maximum hash needed to win a block. The maximum hash starts out as a 256-bit unsigned integer filled with 1s. `difficulty` specifies the number of bits to set to zero, starting with the most significant bit.

## Architecture

"Mining" a TsengToken block consists of guessing a random number, appending it to the block, and hashing the block with `sha256` such that the hash is less than a certain number determined by the difficulty of the network. The goals are to maximize the amount of random numbers that can be guessed at one time and to minimize the amount of time it takes to guess a number + hash the block + check if it's good.

We can leverage the GPU to achieve the first goal. [rust-miner-kernel](https://github.com/Dezzmeister/rust-miner-kernel.git) contains a CUDA kernel that does part of the hashing. The size of a TsengToken block is such that when it is hashed with `sha256`, it will be split into 7 chunks each of 512 bits. The random guess is appended to the block, so the first five chunks will be the same regardless of this guess and these chunks can be hashed by the CPU.

The GPU code is a single CUDA kernel which gets compiled to PTX and executed in parallel on the GPU. The GPU picks up where the CPU left off by guessing random numbers and hashing the last two chunks. The seventh chunk is always the same for any block, so this is stored in static memory on the device. The sixth chunk consists of 16 32-bit unsigned integers. The first 12 are passed to the kernel, which it uses to initialize a message schedule on the stack. The kernel also receives an array of random numbers generated by the CPU. The next 4 `u32`s in the schedule are taken from this random array - each thread executing the kernel takes a different random number. The kernel then hashes the sixth block, copies the seventh block to the schedule, and hashes that as well. Finally the kernel copies the hash variables to the output array.

## WIP

When you run this, a random block is generated and mined. The final software will connect to the network and mine actual blocks.
